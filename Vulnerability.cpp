#include "Vulnerability.h"

Vulnerability::Vulnerability() {
	this->codes = std::vector<Code>();
	this->name = "null";
}

Vulnerability::Vulnerability(const std::string name, codeList codes) {
	this->name = name;
	this->codes = codes;
}

const Vulnerability& Vulnerability::operator=(const Vulnerability& other) {
	this->name = other.name;
	this->codes = other.codes;
	return *this;
}

Vulnerability::Vulnerability(const Vulnerability& other) {
	*this = other;
}

std::string Vulnerability::getName() {
	return this->name;
}

codeList Vulnerability::getCodes() {
	return this->codes;
}

bool Vulnerability::changeCodes() {
	//function in charge of changing the codes.
	//will firstly make a backup in the .jsold files
	//then change all the code objects inside
	//the vulnerability.
	bool keepSuccess = keepOriginalCode();
	if (!keepSuccess) {
		return false;
	}

	for (auto code : this->codes) {
		bool success = code.changeCode();
		if (!success) {
			return false;
		}
	}
	return true;
}

strList Vulnerability::getUniquePaths() {
	std::vector<std::string> uniq;
	for (auto code : this->codes) {
		if (!isIn(uniq, code.getFilePath())) {
			uniq.push_back(code.getFilePath());
			//if the file path was not already added, then add it to the list.
			//if it already exists, do nothing.
		}
	}
	return uniq;
}

bool Vulnerability::keepOriginalCode() {
	std::vector<std::string> uniq = this->getUniquePaths();
	std::string old = "old";
	std::string newPath;
	for (auto path : uniq) {
		newPath = path + old;
		if (!doesExist(newPath)) {
			//makes sure the file does not already exist
			//if it does exist, it means that another 
			//Code object or Vulnerability has the same
			//path and has already changed the original path,
			//so copying the original path to the ".jsold" one
			//would result in an old file that is not the original
			bool success = moveCode(newPath, path);
			if (!success) {
				return false;
			}
		}
	}
	return true;
}

std::vector<strList> Vulnerability::vulnToLst() {
	//converts a vulnerability to a list of strings
	//that include the important parts
	//that will be displayed on the notepad
	//during the defending process.
	std::vector<strList> attributes;
	for (auto item : this->codes) {
		attributes.push_back(item.codeToLst());
	}
	return attributes;
}

std::string Vulnerability::toString() {
	//will make the vulnToLst into a nice
	//string that contains information about
	//the vulnerability that will be displayed
	//in the notepad as part of the insertion
	//process.
	std::vector<strList> attributes = this->vulnToLst();
	std::string message = "Adding vulnerability " + this->getName();
	message += " in files:\n";
	for (auto item : attributes) {
		message += item[0];
		message += " line " + item[1];
		if (item[2] != "0") {
			message += " beggining at char " + item[2];
		}
		message += "\n";
	}
	return message;
}

Vulnerability::~Vulnerability() {

}
